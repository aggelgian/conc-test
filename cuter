#!/usr/bin/env bash

## The arguments are as follows:
## M=$1
## F=$2
## ARGS=$3
## DEPTH=$4 (optional)

function usage() {
    echo "Usage: cuter M F '[A1,...,An]' Depth [ options ]"
    echo "PARAMETERS"
    echo "	M				the module"
    echo "	F				the function"
    echo "	'[A1,...,An]'			the arguments of the functions as a list"
    echo "	Depth				the depth limit of the search"
    echo "OPTIONS"
    echo "	-p=N, --pollers=N		use N pollers"
    echo "	-s=N, --solvers=N		use N solvers"
    echo "	-v, --verbose			verbose execution"
    echo "	-fv --fully-verbose		fully verbose execution (for debugging)"
    echo "	-d, --disable-pmatch		disable pmatch compilation"
    echo "	-r, --recompile			recompile the module"
    exit 1
}

function add_opt() {
    if [ "$1" != "" ]; then
        echo "$1,$2"
    else
        echo $2
    fi
}

function compile_erl() {
    beamfile=$1.beam
    if [ ! -f $beamfile ]; then
        echo -n "File ""$beamfile" "does not exist, "
        erlfile=$mod.erl
        if [ ! -f $erlfile ]; then
            echo "but cannot locate" "$erlfile" "either... exiting"
            exit 1
        fi
        echo -n "creating it... "
        erlc +debug_info $erlfile
        echo "done"
    fi
}

DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )

if [ $# -ge 3 ]; then
    mod=$1
    func=$2
    args=$3
    depth=25
    opts=

    export ERL_LIBS=${DIR}:${ERL_LIBS}

    shift
    shift
    shift

    if [ "$1" != "" ]; then
        re='^[0-9]+$'
        if [[ $1 =~ $re ]] ; then
          depth=$1
          shift
        fi
    fi

    while [ "$1" != "" ]; do
        PARAM=`echo $1 | awk -F= '{print $1}'`
        VALUE=`echo $1 | awk -F= '{print $2}'`
        case $PARAM in
            -p | --pollers)
                opts=$(add_opt "$opts" "{number_of_pollers, $VALUE}")
                ;;
            -s | --solvers)
                opts=$(add_opt "$opts" "{number_of_solvers, $VALUE}")
                ;;
            -v | --verbose)
                opts=$(add_opt "$opts" "verbose_execution_info")
                ;;
            -fv | --fully-verbose)
                opts=$(add_opt "$opts" "fully_verbose_execution_info")
                ;;
            -d | --disable-pmatch)
                opts=$(add_opt "$opts" "disable_pmatch")
                ;;
            -r | --recompile)
		## if the .beam file does not exist, it's pointless to
		## re-compile it; it will be created by compile_erl below
                if [ -f $mod.beam ]; then
                  erlfile=$mod.erl
                  if [ ! -f $erlfile ]; then
                    echo "Error: cannot locate" "$erlfile" " in order to recompile it... exiting"
                    exit 1
                  else
                    echo -n "Recompiling $erlfile... "
                    erlc +debug_info $erlfile
                    echo "done"
                  fi
                fi
                ;;
            *)
                ;;
        esac
        shift
    done

    if [ ! -f $mod.beam ]; then
      compile_erl "$mod"
    fi

    erl -noshell -eval "cuter:run($mod, $func, $args, $depth, [$opts])" -s init stop
else
    usage
fi
